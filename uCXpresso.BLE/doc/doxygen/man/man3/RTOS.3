.TH "RTOS" 3 "Sun Mar 9 2014" "Version v1.0.2" "uCXpresso.BLE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RTOS \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBCEventBit\fP"
.br
.ti -1c
.RI "class \fBCMailBox\fP"
.br
.ti -1c
.RI "class \fBCMutex\fP"
.br
.ti -1c
.RI "class \fBCSemaphore\fP"
.br
.ti -1c
.RI "class \fBCThread\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The RTOS group is power by FreeRTOS 
.SH "Class Documentation"
.PP 
.SH "class CEventBit"
.PP 
EventBit are used to indicate if an event has occurred or not\&. 
.PP
Inherits \fBCObject\fP\&.
.PP
.in -1c
.RI "\fBPublic Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "\fBCEventBit\fP ()"
.br
.ti -1c
.RI "virtual uint32_t \fBset\fP (uint32_t bits)"
.br
.ti -1c
.RI "virtual uint32_t \fBclr\fP (uint32_t bits)"
.br
.ti -1c
.RI "virtual uint32_t \fBget\fP ()"
.br
.ti -1c
.RI "virtual uint32_t \fBwait\fP (uint32_t bitsToWait, bool clearOnExit=true, bool waitForAll=true, uint32_t timeout=MAX_DELAY_TIME)"
.br
.ti -1c
.RI "virtual uint32_t \fBsync\fP (uint32_t bitsToSet, uint32_t bitsToWait, uint32_t timeout=MAX_DELAY_TIME)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "CEventBit::CEventBit ()"

.SH "Member Function Documentation"
.PP 
.SS "virtual uint32_t CEventBit::set (uint32_tbits)\fC [virtual]\fP"

.SS "virtual uint32_t CEventBit::clr (uint32_tbits)\fC [virtual]\fP"

.SS "virtual uint32_t CEventBit::get ()\fC [virtual]\fP"

.SS "virtual uint32_t CEventBit::wait (uint32_tbitsToWait, boolclearOnExit = \fCtrue\fP, boolwaitForAll = \fCtrue\fP, uint32_ttimeout = \fCMAX_DELAY_TIME\fP)\fC [virtual]\fP"

.SS "virtual uint32_t CEventBit::sync (uint32_tbitsToSet, uint32_tbitsToWait, uint32_ttimeout = \fCMAX_DELAY_TIME\fP)\fC [virtual]\fP"

.SH "class CMailBox"
.PP 
Use the CMailbox to receive a message pointer from sender\&. 
.PP
Inherits \fBCObject\fP\&.
.PP
.in -1c
.RI "\fBPublic Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "\fBCMailBox\fP (LPCTSTR name, int \fBcount\fP=DEF_MAIL_COUNT)"
.br
.ti -1c
.RI "virtual MESSAGE_T \fBwait\fP (uint32_t timeout=MAX_DELAY_TIME)"
.br
.ti -1c
.RI "virtual MESSAGE_T \fBpeek\fP (uint32_t timeout=MAX_DELAY_TIME)"
.br
.ti -1c
.RI "virtual int \fBcount\fP ()"
.br
.ti -1c
.RI "virtual bool \fBpost\fP (MESSAGE_T msg, uint32_t timeout=MAX_DELAY_TIME)"
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.in -1c
.PP
.in -1c
.RI "\fBStatic Public Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "static bool \fBpost\fP (LPCTSTR name, MESSAGE_T msg, uint32_t timeout=0)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "CMailBox::CMailBox (LPCTSTRname, intcount = \fCDEF_MAIL_COUNT\fP)"
Constructs a \fBCMailBox\fP object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP is a string to point to describe the name of mailbox\&. 
.br
\fIcount\fP is a integer value to specified the maximum number of message can be contain\&.
.RE
.PP
.PP
.nf
Example:
        class CLedTask: public CThread {
        protected:
            virtual void run() {
            CBus leds(LED2, LED3, LED4, END);
            CMailBox mail("LED");
            int *i;
            while(1) {
                i = (int *) mail\&.wait();
                if ( i ) {
                    leds[*i] = !leds[*i];
                }
            }
            }
    };
.fi
.PP
 
.SH "Member Function Documentation"
.PP 
.SS "virtual MESSAGE_T CMailBox::wait (uint32_ttimeout = \fCMAX_DELAY_TIME\fP)\fC [virtual]\fP"
Call the member function to wait a message from sender\&. 
.PP
\fBParameters:\fP
.RS 4
\fItimeout\fP is an amount of time the task should block for a message to receive\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
MESSAGE_T 
.RE
.PP

.SS "virtual MESSAGE_T CMailBox::peek (uint32_ttimeout = \fCMAX_DELAY_TIME\fP)\fC [virtual]\fP"
Receive a message from mail box without remove 
.SS "virtual int CMailBox::count ()\fC [virtual]\fP"
Call the member function to retrieve the number of message stored in the mailbox\&. 
.PP
\fBReturns:\fP
.RS 4
number of message\&. 
.RE
.PP

.SS "virtual bool CMailBox::post (MESSAGE_Tmsg, uint32_ttimeout = \fCMAX_DELAY_TIME\fP)\fC [virtual]\fP"
Call the member function to send a message to receiver 
.SS "static bool CMailBox::post (LPCTSTRname, MESSAGE_Tmsg, uint32_ttimeout = \fC0\fP)\fC [static]\fP"
Call the member function to send a message to receiver which the same mailbox name\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP is a string to point to which the same name of mailbox to be received the message\&. 
.br
\fImsg\fP is a pointer to the message (void*)\&. 
.br
\fItimeout\fP is a time to wait for post\&. (Default zero) 
.RE
.PP
\fBReturns:\fP
.RS 4
true if post the message successful; otherwise, pose failed\&.
.RE
.PP
.PP
.nf
Example:
    class Task1: public CThread {
    protected:
    virtual void run() {
        int i=0;
        while(1) {
            CMailBox::post(MAIL_LED, &i);
            sleep(500);
        }
    }
 };
.fi
.PP
 
.PP
\fBRemarks:\fP
.RS 4
The \fBCMailBox::post\fP is a static function\&. 
.RE
.PP

.SS "void CMailBox::reset ()"
Reset the mail box to original empty state\&. 
.SH "class CMutex"
.PP 
Use the \fBCMutex\fP class to lock or unlock a resource\&. 
.PP
\fBNote:\fP
.RS 4
Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not\&. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion\&. 
.RE
.PP

.PP
Inherits \fBCObject\fP\&.
.PP
.in -1c
.RI "\fBPublic Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "virtual void \fBlock\fP ()"
.br
.ti -1c
.RI "virtual bool \fBtryLock\fP (uint32_t delay=0)"
.br
.ti -1c
.RI "virtual void \fBunlock\fP ()"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "virtual void CMutex::lock ()\fC [virtual]\fP"
Call the member function to lock (take semaphore) a resource with block when resource in used\&.
.PP
.PP
.nf
Example:
        CMutex mutex;

        CSerial cdc(USB);
        Console (cdc);

        class Task1: public CThread {
        protected:
            virtual void run() {
            while(1) {
                if ( cdc\&.isConnected() ) {
                    mutex\&.lock();
                    con << "1111111111" << endl;
                    mutex\&.unlock();
                }
            }
            }
        };

        class Task2: public CThread {
        protected:
            virtual void run() {
            while(1) {
                if ( cdc\&.isConnected() ) {
                    mutex\&.lock();
                    con << "2222222222" << endl;
                    mutex\&.unlock();
                }
            }
            }
        };
.fi
.PP
 
.SS "virtual bool CMutex::tryLock (uint32_tdelay = \fC0\fP)\fC [virtual]\fP"
Call the member function to lock (take) a resource without block when resource in used\&. 
.PP
\fBReturns:\fP
.RS 4
true if lock successful; otherwise, failed\&. 
.RE
.PP

.SS "virtual void CMutex::unlock ()\fC [virtual]\fP"
Call the member function to unlock (release) a resource\&.
.PP
.PP
.nf
Example:
        CMutex mutex;

        CSerial cdc(USB);
        Console (cdc);

        class Task1: public CThread {
        protected:
            virtual void run() {
            while(1) {
                if ( cdc\&.isConnected() ) {
                    mutex\&.lock();
                    con << "1111111111" << endl;
                    mutex\&.unlock();
                }
            }
            }
        };

        class Task2: public CThread {
        protected:
            virtual void run() {
            while(1) {
                if ( cdc\&.isConnected() ) {
                    mutex\&.lock();
                    con << "2222222222" << endl;
                    mutex\&.unlock();
                }
            }
            }
        };
.fi
.PP
 
.SH "class CSemaphore"
.PP 
The \fBCSemaphore\fP class provides two kinds semaphore which counting and binary\&. 
.PP
\fBNote:\fP
.RS 4
\fBCSemaphore\fP cannot be used before a call to member counting or binary\&. 
.RE
.PP

.PP
Inherits \fBCObject\fP\&.
.PP
.in -1c
.RI "\fBPublic Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "virtual bool \fBcounting\fP (int count, int init=0)"
.br
.ti -1c
.RI "virtual bool \fBbinary\fP ()"
.br
.ti -1c
.RI "virtual bool \fBwait\fP (int timeout=MAX_DELAY_TIME)"
.br
.ti -1c
.RI "virtual int \fBrelease\fP (bool fromISR=false)"
.br
.ti -1c
.RI "virtual int \fBwaiting\fP ()"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "virtual bool CSemaphore::counting (intcount, intinit = \fC0\fP)\fC [virtual]\fP"
Call the member function to creates a counting semaphore\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcount\fP is a integer value to specified the maximum count thate can be reached\&. 
.br
\fIinit\fP is a integer value to assigned to the semaphore when it is created\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if create semaphore successful; otherwise, failed\&. 
.RE
.PP

.SS "virtual bool CSemaphore::binary ()\fC [virtual]\fP"
Call the member function to creates a binary semaphore\&. 
.PP
\fBReturns:\fP
.RS 4
true if create semaphore successful; otherwise, failed\&. 
.RE
.PP
\fBNote:\fP
.RS 4
Binary semaphores and mutexes are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not\&. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion\&. 
.RE
.PP

.SS "virtual bool CSemaphore::wait (inttimeout = \fCMAX_DELAY_TIME\fP)\fC [virtual]\fP"
Call the member function to wait a semaphore available\&. 
.PP
\fBParameters:\fP
.RS 4
\fItimeout\fP is a integer value to specified the millisecond to wait for the semaphore to become available\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if create semaphore successful; otherwise, failed\&.
.RE
.PP
.PP
.nf
Example:
        CSemaphore semLED;

        // resource
        CBus leds(LED1, LED2, LED3, LED4, END);
        int  index;

        // task1
        class Task1: public CThread {
        protected:
            virtual void run() {
                while(1) {
                    index = rand() % 4;     // get a random value in 0~3\&.
                    semLED\&.release();       // release resource\&.
                    sleep(500);
                }
            }
        };

        // task2
        class Task2: public CThread {
    protected:
            virtual void run() {
                while(1) {
                    semLED\&.wait();          // wait resource available\&.
                    leds[index] = !leds[index];
                }
            }
        }

        void main() {
            \&.\&.\&.
            semLED\&.binary();    // set the semaphore in binary mode
            \&.\&.\&.
        }
.fi
.PP
 
.SS "virtual int CSemaphore::release (boolfromISR = \fCfalse\fP)\fC [virtual]\fP"
Call the member function to release a semaphore\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfromISR\fP is a boolean to specified the release occur from interrupt routine\&. (internal used) 
.RE
.PP
\fBReturns:\fP
.RS 4
a integer value to identify the context switch wake\&. (internal used)
.RE
.PP
.PP
.nf
Example:
        CSemaphore semLED;

        // resource
        CBus leds(LED1, LED2, LED3, LED4, END);
        int  index;

        // task1
        class Task1: public CThread {
        protected:
            virtual void run() {
                while(1) {
                    index = rand() % 4;     // get a random value in 0~3\&.
                    semLED\&.release();       // release resource\&.
                    sleep(500);
                }
            }
        };

        // task2
        class Task2: public CThread {
    protected:
            virtual void run() {
                while(1) {
                    semLED\&.wait();          // wait resource available\&.
                    leds[index] = !leds[index];
                }
            }
        }

        void main() {
            \&.\&.\&.
            semLED\&.binary();    // set the semaphore in binary mode
            \&.\&.\&.
        }
.fi
.PP
 
.SS "virtual int CSemaphore::waiting ()\fC [virtual]\fP"
Number of task in waiting 
.SH "class CThread"
.PP 
The \fBCThread\fP class provide the multi-tasking services\&. 
.PP
\fBNote:\fP
.RS 4
The \fBCThread\fP class is an abstract class, child class have to implement the run() member\&. 
.RE
.PP

.PP
Inherits \fBCObject\fP\&.
.PP
Inherited by \fBbleSerial\fP, \fBCDebug\fP, and \fBCShell\fP\&.
.PP
.in -1c
.RI "\fBPublic Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "virtual bool \fBstart\fP (const char *name, int stack=DEF_THREAD_STACK, PRIORITIES_T priority=PRI_LOW)"
.br
.ti -1c
.RI "virtual bool \fBstart\fP ()"
.br
.ti -1c
.RI "virtual void \fBresume\fP ()"
.br
.ti -1c
.RI "virtual void \fBsuspend\fP ()"
.br
.ti -1c
.RI "uint32_t \fBgetStackHighWaterMark\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisSuspend\fP ()"
.br
.ti -1c
.RI "TASK_STATE_T \fBgetState\fP ()"
.br
.ti -1c
.RI "virtual void \fBsetPriority\fP (PRIORITIES_T p)"
.br
.ti -1c
.RI "virtual PRIORITIES_T \fBgetPriority\fP ()"
.br
.ti -1c
.RI "LPCTSTR \fBgetName\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisAlive\fP ()"
.br
.ti -1c
.RI "virtual void \fBkill\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisThread\fP ()"
.br
.in -1c
.PP
.in -1c
.RI "\fBStatic Public Member Functions\fP"
.in +1c

.in +1c
.ti -1c
.RI "static void \fBresumeAll\fP ()"
.br
.ti -1c
.RI "static void \fBsuspendAll\fP ()"
.br
.ti -1c
.RI "static void \fBenterCriticalSection\fP ()"
.br
.ti -1c
.RI "static void \fBexitCriticalSection\fP ()"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "virtual bool CThread::start (const char *name, intstack = \fCDEF_THREAD_STACK\fP, PRIORITIES_Tpriority = \fCPRI_LOW\fP)\fC [virtual]\fP"
Call the member function to start the thread\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP is a descriptive name for the task\&. 
.br
\fIstack\fP is a integer value to specified as the number of stack can hold-not the number of bytes\&. 
.br
\fIpriority\fP at which the task should run\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if successful; otherwise, crate task failed\&.
.RE
.PP
.PP
.nf
Example:
        class CLedTask: public CThread {
        protected:
            virtual void run() {
                CPin led(LED2);
                while( isAlive() ) {    // Is thread in alive?  (when thread be kill, the isAlive will return false)
                    led = !led;
                    sleep(200);
                }
            }
        };

        int main() {
            \&.\&.\&.
            CLedTask ledTask;
            ledTask\&.start("led");   // default stack=128, default priority=low
            \&.\&.\&.
        }
.fi
.PP
 
.SS "virtual bool CThread::start ()\fC [virtual]\fP"
Call the member function to start the thread\&. 
.PP
\fBNote:\fP
.RS 4
the \fBstart()\fP is an overload member function of \fBCThread\fP\&. 
.RE
.PP

.PP
Reimplemented in \fBCDebug\fP, and \fBCShell\fP\&.
.SS "virtual void CThread::resume ()\fC [virtual]\fP"
Call the member function to resume the thread\&.
.PP
.PP
.nf
Example:
    int main() {
        \&.\&.\&.
        CLedTask ledTask;
        ledTask\&.start("led");
        \&.\&.\&.
        ledTask\&.suspend();      // suspend the ledTask
        \&.\&.\&.
        if ( ledTask\&.isSuspend() ) {
            ledTask\&.resume();   // resume the ledTask
        }
        \&.\&.\&.
    }
.fi
.PP
 
.SS "virtual void CThread::suspend ()\fC [virtual]\fP"
Call the member function to suspend the thread\&.
.PP
.PP
.nf
Example:
    int main() {
        \&.\&.\&.
        CLedTask ledTask;
        ledTask\&.start("led");
        \&.\&.\&.
        ledTask\&.suspend();      // suspend the ledTask
        \&.\&.\&.
        if ( ledTask\&.isSuspend() ) {
            ledTask\&.resume();   // resume the ledTask
        }
        \&.\&.\&.
    }
.fi
.PP
 
.SS "uint32_t CThread::getStackHighWaterMark ()"
Call the member function to check the stack high water mark\&. 
.PP
\fBNote:\fP
.RS 4
Or use the shell and type 'task' to check all tasks status\&. 
.RE
.PP

.SS "virtual bool CThread::isSuspend ()\fC [virtual]\fP"
Call the member function to check the task is in suspended or not\&. 
.PP
\fBReturns:\fP
.RS 4
true if task in suspended\&. otherwise, the task in running\&. 
.RE
.PP

.SS "TASK_STATE_T CThread::getState ()"
Retrieve the state of thread object (task) 
.SS "virtual void CThread::setPriority (PRIORITIES_Tp)\fC [virtual]\fP"
Call the member function to change the task's priority\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP is PRIORITIES_T to set a new priority for the task\&. 
.RE
.PP

.SS "virtual PRIORITIES_T CThread::getPriority ()\fC [virtual]\fP"
Call the member function to get the task's priority\&. 
.PP
\fBReturns:\fP
.RS 4
PRIORITIES_T 
.RE
.PP

.SS "LPCTSTR CThread::getName ()"
Call the member function to retrieve the task's name\&. 
.SS "virtual bool CThread::isAlive ()\fC [virtual]\fP"
isAlive is to check the thread is in alive (for run-loop) 
.SS "virtual void CThread::kill ()\fC [virtual]\fP"
kill the thread, call the kill the \fBisAlive()\fP will return false 
.SS "virtual bool CThread::isThread ()\fC [inline]\fP, \fC [virtual]\fP"
\fBisThread()\fP, check the class is inherited from \fBCThread\fP 
.PP
Reimplemented from \fBCObject\fP\&.
.SS "static void CThread::resumeAll ()\fC [static]\fP"
The resumeAll is a static (global) function to resume all suspended tasks\&. 
.SS "static void CThread::suspendAll ()\fC [static]\fP"
The suspendAll is a static (globa) function to suspend all running tasks\&. 
.SS "static void CThread::enterCriticalSection ()\fC [static]\fP"

.SS "static void CThread::exitCriticalSection ()\fC [static]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for uCXpresso\&.BLE from the source code\&.
